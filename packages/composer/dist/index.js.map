{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * @snapie/composer\n * \n * A headless, auth-agnostic composer SDK for Hive blockchain posts and comments.\n * \n * This package handles:\n * - Building post/comment content with media embeds\n * - Generating Hive blockchain operations\n * - 3Speak video upload integration\n * - Image upload utilities\n * \n * It does NOT handle:\n * - Authentication (use any auth method: Aioha, Keychain, HiveSigner, etc.)\n * - UI/UX (bring your own React/Vue/Svelte components)\n * - Signing/broadcasting (handled via callbacks)\n * \n * @example\n * ```typescript\n * import { createSnapComposer, buildCommentOperation } from '@snapie/composer';\n * \n * const composer = createSnapComposer({ appName: 'my-app' });\n * \n * const operations = await composer.buildOperations({\n *   author: 'username',\n *   body: 'Hello Hive!',\n *   images: ['https://...'],\n *   parentAuthor: '',\n *   parentPermlink: 'snaps-container'\n * });\n * \n * // Submit with your preferred auth method\n * await myAuthMethod.broadcast(operations);\n * ```\n */\n\nimport type { CommentOperation, CommentOptionsOperation, Operation } from '@hiveio/dhive';\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/**\n * Configuration options for the composer\n */\nexport interface ComposerOptions {\n    /** Application name for json_metadata (default: \"snapie\") */\n    appName?: string;\n    \n    /** Default tags to include in posts */\n    defaultTags?: string[];\n    \n    /** 3Speak API key for video uploads */\n    threeSpeakApiKey?: string;\n    \n    /** IPFS upload endpoint for thumbnails */\n    ipfsUploadEndpoint?: string;\n    \n    /** Image upload function - must be provided for image support */\n    uploadImage?: (file: File, onProgress?: (progress: number) => void) => Promise<string>;\n    \n    /** Beneficiaries configuration */\n    beneficiaries?: Beneficiary[];\n    \n    /** Whether to require beneficiaries on video posts (default: false) */\n    requireBeneficiariesOnVideo?: boolean;\n}\n\n/**\n * Beneficiary recipient for post rewards\n */\nexport interface Beneficiary {\n    account: string;\n    /** Weight in basis points (100 = 1%, 1000 = 10%, 10000 = 100%) */\n    weight: number;\n}\n\n/**\n * Input for building a comment/post\n */\nexport interface CommentInput {\n    /** Author's Hive username */\n    author: string;\n    \n    /** Post body in markdown */\n    body: string;\n    \n    /** Custom permlink (auto-generated if not provided) */\n    permlink?: string;\n    \n    /** Post title (empty for comments/snaps) */\n    title?: string;\n    \n    /** Parent author (empty for top-level posts) */\n    parentAuthor: string;\n    \n    /** Parent permlink (community tag or container permlink) */\n    parentPermlink: string;\n    \n    /** Image URLs to append to body */\n    images?: string[];\n    \n    /** GIF URL to append to body */\n    gifUrl?: string;\n    \n    /** 3Speak video embed URL */\n    videoEmbedUrl?: string;\n    \n    /** Audio embed URL */\n    audioEmbedUrl?: string;\n    \n    /** Custom tags (hashtags extracted automatically from body too) */\n    tags?: string[];\n    \n    /** Custom json_metadata fields */\n    metadata?: Record<string, unknown>;\n    \n    /** Override beneficiaries for this specific post */\n    beneficiaries?: Beneficiary[];\n    \n    /** Max accepted payout (default: \"1000000.000 HBD\") */\n    maxAcceptedPayout?: string;\n    \n    /** Percent HBD (default: 10000 = 100%) */\n    percentHbd?: number;\n    \n    /** Allow votes (default: true) */\n    allowVotes?: boolean;\n    \n    /** Allow curation rewards (default: true) */\n    allowCurationRewards?: boolean;\n}\n\n/**\n * Result from building operations\n */\nexport interface ComposerResult {\n    /** The operations to broadcast */\n    operations: Operation[];\n    \n    /** The generated permlink */\n    permlink: string;\n    \n    /** The final body content */\n    body: string;\n    \n    /** The json_metadata object */\n    metadata: Record<string, unknown>;\n}\n\n/**\n * Video upload progress callback\n */\nexport type VideoProgressCallback = (progress: number, status: 'uploading' | 'processing' | 'complete' | 'error') => void;\n\n/**\n * Video upload result\n */\nexport interface VideoUploadResult {\n    embedUrl: string;\n    videoId: string;\n}\n\n// ============================================================================\n// Utilities\n// ============================================================================\n\n/**\n * Generate a unique permlink from current timestamp\n */\nexport function generatePermlink(): string {\n    return new Date()\n        .toISOString()\n        .replace(/[^a-zA-Z0-9]/g, \"\")\n        .toLowerCase();\n}\n\n/**\n * Extract hashtags from text content\n * \n * @param text - Text to extract hashtags from\n * @returns Array of hashtag strings (without the # symbol)\n */\nexport function extractHashtags(text: string): string[] {\n    const hashtagRegex = /#(\\w+)/g;\n    const matches = text.match(hashtagRegex) || [];\n    return matches.map(hashtag => hashtag.slice(1));\n}\n\n/**\n * Build markdown image syntax from URL\n */\nexport function imageToMarkdown(url: string): string {\n    return `![image](${url})`;\n}\n\n/**\n * Build markdown for multiple images\n */\nexport function imagesToMarkdown(urls: string[]): string {\n    return urls.map(imageToMarkdown).join('\\n');\n}\n\n/**\n * Append media embeds to body content\n */\nexport function appendMediaToBody(\n    body: string,\n    options: {\n        images?: string[];\n        gifUrl?: string;\n        videoEmbedUrl?: string;\n        audioEmbedUrl?: string;\n    }\n): string {\n    let result = body;\n    \n    if (options.videoEmbedUrl) {\n        result += `\\n\\n${options.videoEmbedUrl}`;\n    }\n    \n    if (options.audioEmbedUrl) {\n        result += `\\n\\n${options.audioEmbedUrl}`;\n    }\n    \n    if (options.images && options.images.length > 0) {\n        result += `\\n\\n${imagesToMarkdown(options.images)}`;\n    }\n    \n    if (options.gifUrl) {\n        result += `\\n\\n![gif](${options.gifUrl})`;\n    }\n    \n    return result;\n}\n\n// ============================================================================\n// Operation Builders\n// ============================================================================\n\n/**\n * Build a comment operation\n */\nexport function buildCommentOperation(input: {\n    parentAuthor: string;\n    parentPermlink: string;\n    author: string;\n    permlink: string;\n    title: string;\n    body: string;\n    metadata: Record<string, unknown>;\n}): CommentOperation {\n    return [\n        'comment',\n        {\n            parent_author: input.parentAuthor,\n            parent_permlink: input.parentPermlink,\n            author: input.author,\n            permlink: input.permlink,\n            title: input.title,\n            body: input.body,\n            json_metadata: JSON.stringify(input.metadata)\n        }\n    ];\n}\n\n/**\n * Build a comment_options operation (for beneficiaries, payout settings, etc.)\n */\nexport function buildCommentOptionsOperation(input: {\n    author: string;\n    permlink: string;\n    maxAcceptedPayout?: string;\n    percentHbd?: number;\n    allowVotes?: boolean;\n    allowCurationRewards?: boolean;\n    beneficiaries?: Beneficiary[];\n}): CommentOptionsOperation {\n    const extensions: [0, { beneficiaries: { account: string; weight: number }[] }][] = [];\n    \n    if (input.beneficiaries && input.beneficiaries.length > 0) {\n        // Sort beneficiaries alphabetically by account (required by Hive)\n        const sortedBeneficiaries = [...input.beneficiaries].sort((a, b) => \n            a.account.localeCompare(b.account)\n        );\n        \n        extensions.push([0, { beneficiaries: sortedBeneficiaries }]);\n    }\n    \n    return [\n        'comment_options',\n        {\n            author: input.author,\n            permlink: input.permlink,\n            max_accepted_payout: input.maxAcceptedPayout ?? '1000000.000 HBD',\n            percent_hbd: input.percentHbd ?? 10000,\n            allow_votes: input.allowVotes ?? true,\n            allow_curation_rewards: input.allowCurationRewards ?? true,\n            extensions\n        }\n    ];\n}\n\n// ============================================================================\n// 3Speak Video Upload (TUS Protocol)\n// ============================================================================\n\n/**\n * Upload a video to 3Speak using TUS protocol\n * \n * @param file - Video file to upload\n * @param options - Upload options\n * @returns Promise resolving to embed URL\n */\nexport async function uploadVideoTo3Speak(\n    file: File,\n    options: {\n        apiKey: string;\n        owner: string;\n        appName?: string;\n        onProgress?: VideoProgressCallback;\n    }\n): Promise<VideoUploadResult> {\n    // Dynamic import to avoid bundling tus-js-client when not needed\n    const tus = await import('tus-js-client');\n    \n    return new Promise((resolve, reject) => {\n        let embedUrl: string | null = null;\n        \n        const upload = new tus.Upload(file, {\n            endpoint: 'https://embed.3speak.tv/uploads',\n            retryDelays: [0, 3000, 5000, 10000, 20000],\n            metadata: {\n                filename: file.name,\n                owner: options.owner,\n                frontend_app: options.appName ?? 'snapie',\n                short: 'true'\n            },\n            headers: {\n                'X-API-Key': options.apiKey\n            },\n            onError: (error) => {\n                options.onProgress?.(0, 'error');\n                reject(error);\n            },\n            onProgress: (bytesUploaded, bytesTotal) => {\n                const percentage = (bytesUploaded / bytesTotal) * 100;\n                options.onProgress?.(Math.round(percentage), 'uploading');\n            },\n            onAfterResponse: (req, res) => {\n                const url = res.getHeader('X-Embed-URL');\n                if (url) {\n                    embedUrl = url;\n                }\n            },\n            onSuccess: () => {\n                if (embedUrl) {\n                    options.onProgress?.(100, 'complete');\n                    \n                    // Extract video ID from embed URL\n                    const videoId = extractVideoIdFromEmbedUrl(embedUrl);\n                    \n                    resolve({\n                        embedUrl,\n                        videoId: videoId ?? ''\n                    });\n                } else {\n                    options.onProgress?.(0, 'error');\n                    reject(new Error('Failed to get embed URL from server'));\n                }\n            }\n        });\n        \n        upload.start();\n    });\n}\n\n/**\n * Extract video ID from 3Speak embed URL\n * \n * @example\n * // Input: \"https://play.3speak.tv/embed?v=username/abc123\"\n * // Output: \"abc123\"\n */\nexport function extractVideoIdFromEmbedUrl(embedUrl: string): string | null {\n    try {\n        const url = new URL(embedUrl);\n        const videoParam = url.searchParams.get('v');\n        if (videoParam) {\n            const parts = videoParam.split('/');\n            return parts[1] ?? null;\n        }\n        return null;\n    } catch {\n        return null;\n    }\n}\n\n/**\n * Set thumbnail for a 3Speak video\n */\nexport async function set3SpeakThumbnail(\n    videoId: string,\n    thumbnailUrl: string,\n    apiKey: string\n): Promise<void> {\n    const response = await fetch(`https://embed.3speak.tv/video/${videoId}/thumbnail`, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            'X-API-Key': apiKey\n        },\n        body: JSON.stringify({ thumbnail_url: thumbnailUrl })\n    });\n    \n    if (!response.ok) {\n        throw new Error(`Failed to set thumbnail: ${response.status} - ${response.statusText}`);\n    }\n}\n\n/**\n * Upload a file to IPFS (3Speak supernode)\n */\nexport async function uploadToIPFS(\n    file: File | Blob,\n    endpoint: string = 'http://65.21.201.94:5002/api/v0/add'\n): Promise<string> {\n    const formData = new FormData();\n    formData.append('file', file);\n    \n    const response = await fetch(endpoint, {\n        method: 'POST',\n        body: formData\n    });\n    \n    if (!response.ok) {\n        throw new Error(`IPFS upload failed: ${response.status} - ${response.statusText}`);\n    }\n    \n    const responseText = await response.text();\n    const lines = responseText.trim().split('\\n');\n    const lastLine = lines[lines.length - 1];\n    const result = JSON.parse(lastLine);\n    \n    return `https://ipfs.3speak.tv/ipfs/${result.Hash}`;\n}\n\n// ============================================================================\n// Thumbnail Extraction\n// ============================================================================\n\n/**\n * Extract a thumbnail frame from a video file\n * \n * @param file - Video file\n * @param seekTime - Time in seconds to capture frame (default: 0.5)\n * @returns Promise resolving to thumbnail blob\n */\nexport async function extractVideoThumbnail(\n    file: File,\n    seekTime: number = 0.5\n): Promise<Blob> {\n    return new Promise((resolve, reject) => {\n        const url = URL.createObjectURL(file);\n        const video = document.createElement('video');\n        \n        video.src = url;\n        video.crossOrigin = 'anonymous';\n        video.muted = true;\n        \n        video.addEventListener('loadeddata', () => {\n            video.currentTime = seekTime;\n        });\n        \n        video.addEventListener('seeked', () => {\n            const canvas = document.createElement('canvas');\n            canvas.width = video.videoWidth;\n            canvas.height = video.videoHeight;\n            \n            const ctx = canvas.getContext('2d');\n            if (!ctx) {\n                reject(new Error('Failed to get canvas context'));\n                return;\n            }\n            \n            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n            \n            canvas.toBlob(\n                (blob) => {\n                    URL.revokeObjectURL(url);\n                    if (blob) {\n                        resolve(blob);\n                    } else {\n                        reject(new Error('Failed to create thumbnail blob'));\n                    }\n                },\n                'image/jpeg',\n                0.9\n            );\n        });\n        \n        video.addEventListener('error', () => {\n            URL.revokeObjectURL(url);\n            reject(new Error('Failed to load video'));\n        });\n        \n        video.load();\n    });\n}\n\n// ============================================================================\n// Main Composer\n// ============================================================================\n\n/**\n * Default composer options\n */\nconst DEFAULT_OPTIONS: Required<Pick<ComposerOptions, 'appName' | 'defaultTags' | 'requireBeneficiariesOnVideo'>> = {\n    appName: 'snapie',\n    defaultTags: [],\n    requireBeneficiariesOnVideo: false\n};\n\n/**\n * Create a configured composer instance\n * \n * @example\n * ```typescript\n * const composer = createSnapComposer({\n *   appName: 'my-app',\n *   beneficiaries: [{ account: 'my-app', weight: 500 }] // 5%\n * });\n * \n * const result = await composer.buildOperations({\n *   author: 'user',\n *   body: 'Hello!',\n *   parentAuthor: '',\n *   parentPermlink: 'snaps'\n * });\n * \n * // Broadcast with any auth method\n * await myAuth.broadcast(result.operations);\n * ```\n */\nexport function createSnapComposer(options: ComposerOptions = {}) {\n    const config = { ...DEFAULT_OPTIONS, ...options };\n    \n    return {\n        /**\n         * Build operations for a comment/post\n         */\n        buildOperations(input: CommentInput): ComposerResult {\n            const permlink = input.permlink ?? generatePermlink();\n            \n            // Build body with media\n            const body = appendMediaToBody(input.body, {\n                images: input.images,\n                gifUrl: input.gifUrl,\n                videoEmbedUrl: input.videoEmbedUrl,\n                audioEmbedUrl: input.audioEmbedUrl\n            });\n            \n            // Extract and combine tags\n            const extractedTags = extractHashtags(body);\n            const allTags = [...new Set([\n                ...config.defaultTags,\n                ...(input.tags ?? []),\n                ...extractedTags\n            ])];\n            \n            // Build metadata\n            const metadata: Record<string, unknown> = {\n                app: config.appName,\n                tags: allTags,\n                ...(input.images && input.images.length > 0 ? { images: input.images } : {}),\n                ...input.metadata\n            };\n            \n            // Build comment operation\n            const commentOp = buildCommentOperation({\n                parentAuthor: input.parentAuthor,\n                parentPermlink: input.parentPermlink,\n                author: input.author,\n                permlink,\n                title: input.title ?? '',\n                body,\n                metadata\n            });\n            \n            const operations: Operation[] = [commentOp];\n            \n            // Determine if we need comment_options (beneficiaries or custom payout settings)\n            const beneficiaries = input.beneficiaries ?? config.beneficiaries;\n            const hasCustomPayoutSettings = \n                input.maxAcceptedPayout !== undefined ||\n                input.percentHbd !== undefined ||\n                input.allowVotes !== undefined ||\n                input.allowCurationRewards !== undefined;\n            \n            const needsBeneficiaries = beneficiaries && beneficiaries.length > 0;\n            const requiresBeneficiaries = config.requireBeneficiariesOnVideo && input.videoEmbedUrl;\n            \n            if (needsBeneficiaries || hasCustomPayoutSettings || requiresBeneficiaries) {\n                const optionsOp = buildCommentOptionsOperation({\n                    author: input.author,\n                    permlink,\n                    maxAcceptedPayout: input.maxAcceptedPayout,\n                    percentHbd: input.percentHbd,\n                    allowVotes: input.allowVotes,\n                    allowCurationRewards: input.allowCurationRewards,\n                    beneficiaries: needsBeneficiaries ? beneficiaries : undefined\n                });\n                \n                operations.push(optionsOp);\n            }\n            \n            return {\n                operations,\n                permlink,\n                body,\n                metadata\n            };\n        },\n        \n        /**\n         * Upload a video to 3Speak\n         */\n        async uploadVideo(\n            file: File,\n            owner: string,\n            onProgress?: VideoProgressCallback\n        ): Promise<VideoUploadResult> {\n            if (!config.threeSpeakApiKey) {\n                throw new Error('3Speak API key not configured');\n            }\n            \n            return uploadVideoTo3Speak(file, {\n                apiKey: config.threeSpeakApiKey,\n                owner,\n                appName: config.appName,\n                onProgress\n            });\n        },\n        \n        /**\n         * Extract and upload a video thumbnail\n         */\n        async uploadThumbnail(\n            videoFile: File,\n            uploadFn?: (blob: Blob) => Promise<string>\n        ): Promise<string> {\n            const thumbnailBlob = await extractVideoThumbnail(videoFile);\n            \n            if (uploadFn) {\n                return uploadFn(thumbnailBlob);\n            }\n            \n            // Default: upload to 3Speak IPFS\n            return uploadToIPFS(\n                thumbnailBlob,\n                config.ipfsUploadEndpoint\n            );\n        },\n        \n        /**\n         * Set video thumbnail via 3Speak API\n         */\n        async setVideoThumbnail(videoId: string, thumbnailUrl: string): Promise<void> {\n            if (!config.threeSpeakApiKey) {\n                throw new Error('3Speak API key not configured');\n            }\n            \n            return set3SpeakThumbnail(videoId, thumbnailUrl, config.threeSpeakApiKey);\n        },\n        \n        /**\n         * Upload images (requires uploadImage function in config)\n         */\n        async uploadImages(\n            files: File[],\n            onProgress?: (index: number, progress: number) => void\n        ): Promise<string[]> {\n            if (!config.uploadImage) {\n                throw new Error('uploadImage function not configured');\n            }\n            \n            const results: string[] = [];\n            \n            for (let i = 0; i < files.length; i++) {\n                const url = await config.uploadImage(\n                    files[i],\n                    (progress) => onProgress?.(i, progress)\n                );\n                results.push(url);\n            }\n            \n            return results;\n        }\n    };\n}\n\n// ============================================================================\n// Re-exports for convenience\n// ============================================================================\n\nexport type {\n    CommentOperation,\n    CommentOptionsOperation,\n    Operation\n} from '@hiveio/dhive';\n"],"mappings":"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","names":[]}